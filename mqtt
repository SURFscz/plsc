#!/usr/bin/env python
# -*- coding: future_fstrings -*-

import sys, time
import yaml, re, json
import socket
import copy
import threading
import traceback

import util, mqtt_util, mqtt_flat
from mqtt_util import mqttClient
from sldap import sLDAP
from sbs import SBS

if len(sys.argv) < 2:
    sys.exit(sys.argv[0] + "  <conf.yml>")
    exit()

with open(sys.argv[1]) as f:
  config = yaml.safe_load(f)

src = SBS(config['sbs']['src'])
dst = sLDAP(config['ldap']['dst'])
fqdn = socket.getfqdn() + ':slp'
mqtt_topic = config['mqtt']['topic']

def unknown(method, action, msg):
    print(f"don\'t know what to do with {method} {action} {msg}")
    return 0

def collaboration(method, action, msg):
    if action == "collaborations/invites":
        print(f"discarding collaborations invites msg")
        return
    cid = int(msg['id'])
    print(f"handling collaboration {method} {action} {cid} {msg}")
    # Handling POST makes no sense, since a new CO is not
    # Connected to any service?
    if method == 'delete':
        mqtt_util.delete_collaboration(src, dst, config, cid)
    elif method == 'put':
        mqtt_util.update_collaboration(src, dst, config, cid)
    return cid

def service(method, action, msg):
    sid = int(msg['id'])
    print(f"handling service {method} {action} {sid}")
    if method == 'delete':
        mqtt_util.delete_service(src, dst, config, sid)
    else:
        mqtt_util.create_service(src, dst, config, sid)
    return 0

def collab_service(method, action, msg):
    cid = int(msg['collaboration_id'])
    sid = int(msg['service_id'])
    print(f"handling collaboration service {method} s:{sid} c:{cid} {msg}")
    service = src.service(sid)
    seid = service['entity_id']
    print(f"seid: {seid}")
    if method == 'delete':
        mqtt_util.remove_collaboration(src, dst, config, cid, sid)
    else:
        mqtt_util.create_collaboration(src, dst, config, cid, sid)
    return cid
        
def collab_member(method, action, msg):
    print(f"handling collaboration membership {method} {action} {msg}")
    cid = int(msg['collaboration_id'])
    uid = int(msg['user_id'])
    if method == 'delete':
        mqtt_util.clean_collaboration(src, dst, config, cid)
    else:
        mqtt_util.collab_member(src, dst, config, cid, uid)
    return cid

def invitation(method, action, msg):
    if action == 'invitations/accept' and method == 'put':
        print(f"handling invitations {method} {action} {msg}")
        cid = int(msg['collaboration_id'])
        uid = int(msg['user_id'])
        users = src.users(cid)
        mqtt_util.create_user(src, dst, config, cid, users[uid])
    else:
        print(f"discarding invitations {method} {action} {msg}")
    return cid

def join_request(method, action, msg):
    if action == 'join_requests/accept' and method == 'put':
        print(f"handling join_request {method} {action} {msg}")
        cid = int(msg['collaboration_id'])
        uid = int(msg['user_id'])
        users = src.users(cid)
        mqtt_util.create_user(src, dst, config, cid, users[uid])
        return cid
    else:
        print(f"discarding join_request {method} {action} {msg}")
        return 0

def group(method, action, msg):
    print(f"handling group {method} {action} {msg}")
    cid = int(msg['collaboration_id'])
    gid = int(msg['id'])
    if method == "delete":
        mqtt_util.delete_group(src, dst, config, cid, gid, msg)
    else:
        mqtt_util.add_group(src, dst, config, cid, gid)
    return cid

def group_member(method, action, msg):
    print(f"handling group_member {method} {action} {msg}")
    cid = int(msg['collaboration_id'])
    if method == "delete":
        gid = int(msg['id'])
        mqtt_util.remove_group_users(src, dst, config, cid, gid)
    else:
        gid = int(msg['group_id'])
        mqtt_util.group_users(src, dst, config, cid, gid)
    return cid

def on_message(message):
    print("-")
    switcher = {
        'collaborations': collaboration,
        'collaboration_memberships': collab_member,
        'services': service,
        'collaborations_services': collab_service,
        'invitations': invitation,
        'join_requests': join_request,
        'groups': group,
        'group_members': group_member,
    }
    topic = message.topic
    method = topic.rsplit('/', 1)[-1]
    action = topic[8:].rsplit('/', 1)[0]
    subject = action.split('/')[0]
    msg = json.loads(message.payload.decode("utf-8"))

    func = switcher.get(subject, unknown)
    try:
        cid = func(method, action, msg)
        mqtt_flat.flatten(dst, dst, src, config, cid)
    except:
        traceback.print_exc()

mqtt = mqttClient(config['mqtt'])

while True:
    msg = mqtt.subscribe(mqtt_topic)
    on_message(msg)
