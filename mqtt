#!/usr/bin/env python
# -*- coding: future_fstrings -*-

import sys, time
import yaml, re, json
import socket
import copy
import threading
import traceback
import paho.mqtt.client as client

import util, mqtt_util
from sldap import sLDAP
from sbs import SBS

if len(sys.argv) < 2:
    sys.exit(sys.argv[0] + "  <conf.yml>")
    exit()

with open(sys.argv[1]) as f:
  config = yaml.safe_load(f)

src = SBS(config['sbs']['src'])
dst = sLDAP(config['ldap']['dst'])
fqdn = socket.getfqdn() + ':slp'
mqtt_topic = config['mqtt']['topic']
mqtt_host = config['mqtt']['host']
mqtt_client = config['mqtt']['client']

def unknown(method, action, msg):
    print(f"don\'t know what to do with {method} {action} {msg}")

def collaboration(method, action, msg):
    if action == "collaborations/invites":
        print(f"discarding collaborations invites msg")
        return
    print(f"handling collaboration {method} {action} {msg}")
    if method == 'delete':
        split = action.split('/')
        cid = split[1]
    else:
        cid = msg['id']
    print(f"handling collaboration {method} {action} {cid} {msg}")
    # Handling POST makes no sense, since a new CO is not
    # Connected to any service?
    if method == 'delete':
        mqtt_util.delete_collaboration(src, dst, config, cid)
    elif method == 'put':
        mqtt_util.update_collaboration(src, dst, config, cid)


def service(method, action, msg):
    if method == 'delete':
        sid = action.split('/')[1]
    else:
        sid = msg['id']
    print(f"handling service {method} {action} {sid} {msg}")
    if method == 'delete':
        mqtt_util.delete_service(src, dst, config, sid)
    else:
        mqtt_util.create_service(src, dst, config, sid)

def collab_service(method, action, msg):
    if method == 'delete':
        split = action.split('/')
        cid = split[1]
        sid = split[2]
    else:
        cid = msg['collaboration_id']
        sid = msg['service_id']
    print(f"handling collaboration service {method} s:{sid} c:{cid} {msg}")
    service = src.service(sid)
    seid = service['entity_id']
    print(f"seid: {seid}")
    if method == 'delete':
        mqtt_util.remove_collaboration(src, dst, config, cid, sid)
    else:
        mqtt_util.create_collaboration(src, dst, config, cid, sid)
        
def invitation(method, action, msg):
    if action == 'invitations/accept' and method == 'put':
        print(f"handling invitations {method} {action} {msg}")
        cid = msg['collaboration_id']
        uid = msg['user_id']
        users = src.users(cid)
        mqtt_util.create_user(src, dst, config, cid, users[uid])
    else:
        print(f"discarding invitations {method} {action} {msg}")

def join_request(method, action, msg):
    if action == 'join_requests/accept' and method == 'put':
        print(f"handling join_request {method} {action} {msg}")
        cid = msg['collaboration_id']
        uid = msg['user_id']
        users = src.users(cid)
        mqtt_util.create_user(src, dst, config, cid, users[uid])
    else:
        print(f"discarding join_request {method} {action} {msg}")

def group(method, action, msg):
    print(f"handling group {method} {action} {msg}")
    if method == "delete":
        split = action.split('/')
        gid = split[1]
        mqtt_util.delete_group(src, dst, config, gid)
    else:
        gid = msg['id']
        cid = msg['collaboration_id']
        mqtt_util.add_group(src, dst, config, cid, gid)

def group_member(method, action, msg):
    print(f"handling group_member {method} {action} {msg}")
    cid = msg['collaboration_id']
    if method == "delete":
        gid = msg['id']
        mqtt_util.remove_group_users(src, dst, config, cid, gid)
    else:
        gid = msg['group_id']
        mqtt_util.group_users(src, dst, config, cid, gid)

def on_message(client, userdata, message):
    print("-")
    switcher = {
        'collaborations': collaboration,
        'services': service,
        'collaborations_services': collab_service,
        'invitations': invitation,
        'join_requests': join_request,
        'groups': group,
        'group_members': group_member,
    }
    topic = message.topic
    method = topic.rsplit('/', 1)[-1]
    action = topic[8:].rsplit('/', 1)[0]
    subject = action.split('/')[0]
    msg = json.loads(message.payload.decode("utf-8"))

    func = switcher.get(subject, unknown)
    try:
        func(method, action, msg)
    except:
        traceback.print_exc()

def on_log(client, userdata, level, buf):
    print("log: ",buf)

mqtt = client.Client(mqtt_client, clean_session=False)
mqtt.connect(mqtt_host)

mqtt.subscribe(mqtt_topic, qos=1)
mqtt.on_message = on_message
#mqtt.on_log = on_log
mqtt.loop_start()

#forever = threading.Event()
#forever.wait()

while True:
    time.sleep(1)
